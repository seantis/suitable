# This is an auto-generated file. Please don't manually edit.
# Instead call `scripts/generate_module_hints.py`

from _typeshed import StrPath
from suitable.runner_results import RunnerResults
from suitable.types import Incomplete
from typing import Literal, overload
from typing_extensions import Never as NotSupported


class AnsibleModules:
    def apt(
        self,
        *,
        name: NotSupported = ...,
        state: Literal['absent', 'build-dep', 'latest', 'present', 'fixed'] = 'present',
        update_cache: bool = ...,
        update_cache_retries: int = 5,
        update_cache_retry_max_delay: int = 12,
        cache_valid_time: int | str = 0,
        purge: bool = False,
        default_release: str = ...,
        install_recommends: bool = ...,
        force: bool = False,
        allow_unauthenticated: bool = False,
        upgrade: Literal['dist', 'full', 'no', 'safe', 'yes'] = 'no',
        dpkg_options: str = 'force-confdef,force-confold',
        deb: str = ...,
        autoremove: bool = False,
        autoclean: bool = False,
        policy_rc_d: int = ...,
        only_upgrade: bool = False,
        force_apt_get: bool = False,
    ) -> RunnerResults: ...
    def apt_key(
        self,
        *,
        id: str = ...,
        data: str = ...,
        file: str = ...,
        keyring: str = ...,
        url: str = ...,
        keyserver: str = ...,
        state: Literal['absent', 'present'] = 'present',
        validate_certs: bool = True,
    ) -> RunnerResults: ...
    def apt_repository(
        self,
        *,
        repo: str,
        state: Literal['absent', 'present'] = 'present',
        mode: str = '0644',
        update_cache: bool = True,
        update_cache_retries: int = 5,
        update_cache_retry_max_delay: int = 12,
        validate_certs: bool = True,
        filename: str = ...,
        codename: str = ...,
    ) -> RunnerResults: ...
    def assemble(
        self,
        *,
        src: StrPath,
        dest: StrPath,
        backup: bool = False,
        delimiter: str = ...,
        remote_src: bool = True,
        regexp: str = ...,
        ignore_hidden: bool = False,
        validate: str = ...,
    ) -> RunnerResults: ...
    def async_status(
        self,
        *,
        jid: str,
        mode: Literal['cleanup', 'status'] = 'status',
    ) -> RunnerResults: ...
    @overload
    def command(
        self,
        *,
        cmd: str = ...,
        argv: NotSupported = ...,
        creates: StrPath = ...,
        removes: StrPath = ...,
        chdir: StrPath = ...,
        warn: bool = True,
        stdin: str = ...,
        stdin_add_newline: bool = True,
        strip_empty_ends: bool = True,
    ) -> RunnerResults: ...
    @overload
    def command(self, arg: str, /) -> RunnerResults: ...
    def copy(
        self,
        *,
        src: StrPath = ...,
        content: str = ...,
        dest: StrPath,
        backup: bool = False,
        force: bool = True,
        mode: StrPath = ...,
        directory_mode: str = ...,
        remote_src: bool = False,
        follow: bool = False,
        local_follow: bool = True,
        checksum: str = ...,
    ) -> RunnerResults: ...
    def cron(
        self,
        *,
        name: str = ...,
        user: str = ...,
        job: str = ...,
        state: Literal['absent', 'present'] = 'present',
        cron_file: str = ...,
        backup: bool = False,
        minute: str = '*',
        hour: str = '*',
        day: str = '*',
        month: str = '*',
        weekday: str = '*',
        reboot: bool = False,
        special_time: Literal['annually', 'daily', 'hourly', 'monthly', 'reboot', 'weekly', 'yearly'] = ...,
        disabled: bool = False,
        env: bool = False,
        insertafter: str = ...,
        insertbefore: str = ...,
    ) -> RunnerResults: ...
    def debconf(
        self,
        *,
        name: str,
        question: str = ...,
        vtype: Literal['boolean', 'error', 'multiselect', 'note', 'password', 'seen', 'select', 'string', 'text', 'title'] = ...,
        value: str = ...,
        unseen: bool = False,
    ) -> RunnerResults: ...
    def dnf5(
        self,
        *,
        name: NotSupported = ...,
        list: str = ...,
        state: Literal['absent', 'present', 'installed', 'removed', 'latest'] = ...,
        enablerepo: NotSupported = ...,
        disablerepo: NotSupported = ...,
        conf_file: str = ...,
        disable_gpg_check: bool = False,
        installroot: str = '/',
        releasever: str = ...,
        autoremove: bool = False,
        exclude: NotSupported = ...,
        skip_broken: bool = False,
        update_cache: bool = False,
        update_only: bool = False,
        security: bool = False,
        bugfix: bool = False,
        enable_plugin: NotSupported = ...,
        disable_plugin: NotSupported = ...,
        disable_excludes: str = ...,
        validate_certs: bool = True,
        sslverify: bool = True,
        allow_downgrade: bool = False,
        install_repoquery: bool = True,
        download_only: bool = False,
        lock_timeout: int = 30,
        install_weak_deps: bool = True,
        download_dir: str = ...,
        allowerasing: bool = False,
        nobest: bool = ...,
        best: bool = ...,
        cacheonly: bool = False,
    ) -> RunnerResults: ...
    def file(
        self,
        *,
        path: StrPath,
        state: Literal['absent', 'directory', 'file', 'hard', 'link', 'touch'] = 'file',
        src: StrPath = ...,
        recurse: bool = False,
        force: bool = False,
        follow: bool = True,
        modification_time: str = ...,
        modification_time_format: str = '%Y%m%d%H%M.%S',
        access_time: str = ...,
        access_time_format: str = '%Y%m%d%H%M.%S',
    ) -> RunnerResults: ...
    def find(
        self,
        *,
        age: str = ...,
        patterns: NotSupported = ...,
        excludes: NotSupported = ...,
        contains: str = ...,
        paths: NotSupported,
        file_type: Literal['any', 'directory', 'file', 'link'] = 'file',
        recurse: bool = False,
        size: str = ...,
        age_stamp: Literal['atime', 'ctime', 'mtime'] = 'mtime',
        hidden: bool = False,
        follow: bool = False,
        get_checksum: bool = False,
        use_regex: bool = False,
        depth: int = ...,
    ) -> RunnerResults: ...
    def gather_facts(
        self,
        *,
        parallel: bool = ...,
    ) -> RunnerResults: ...
    def get_url(
        self,
        *,
        url: str,
        dest: StrPath,
        tmp_dest: StrPath = ...,
        force: bool = False,
        backup: bool = False,
        sha256sum: str = '',
        checksum: str = '',
        use_proxy: bool = True,
        validate_certs: bool = True,
        timeout: int = 10,
        headers: NotSupported = ...,
        url_username: str = ...,
        url_password: str = ...,
        force_basic_auth: bool = False,
        client_cert: StrPath = ...,
        client_key: StrPath = ...,
        http_agent: str = 'ansible-httpget',
    ) -> RunnerResults: ...
    def git(
        self,
        *,
        repo: str,
        dest: str,
        version: str = 'HEAD',
        accept_hostkey: bool = False,
        ssh_opts: str = ...,
        key_file: str = ...,
        reference: str = ...,
        remote: str = 'origin',
        refspec: str = ...,
        force: bool = False,
        depth: str = ...,
        clone: bool = True,
        update: bool = True,
        executable: str = ...,
        bare: bool = False,
        umask: str = ...,
        recursive: bool = True,
        track_submodules: bool = False,
        verify_commit: bool = False,
        archive: str = ...,
        archive_prefix: str = ...,
        separate_git_dir: str = ...,
        gpg_whitelist: NotSupported = ...,
    ) -> RunnerResults: ...
    def group(
        self,
        *,
        name: str,
        gid: int = ...,
        state: Literal['absent', 'present'] = 'present',
        system: bool = False,
        local: bool = False,
        non_unique: bool = False,
    ) -> RunnerResults: ...
    def import_playbook(self, arg: str, /) -> RunnerResults: ...
    def import_role(
        self,
        *,
        name: str,
        tasks_from: str = 'main',
        vars_from: str = 'main',
        defaults_from: str = 'main',
        allow_duplicates: bool = True,
        handlers_from: str = 'main',
    ) -> RunnerResults: ...
    def import_tasks(self, arg: str, /) -> RunnerResults: ...
    def include(self, arg: str, /) -> RunnerResults: ...
    def include_role(
        self,
        *,
        apply: str = ...,
        name: str,
        tasks_from: str = 'main',
        vars_from: str = 'main',
        defaults_from: str = 'main',
        allow_duplicates: bool = True,
        public: bool = False,
        handlers_from: str = 'main',
    ) -> RunnerResults: ...
    @overload
    def include_tasks(
        self,
        *,
        file: str = ...,
        apply: str = ...,
    ) -> RunnerResults: ...
    @overload
    def include_tasks(self, arg: str, /) -> RunnerResults: ...
    @overload
    def include_vars(
        self,
        *,
        file: StrPath = ...,
        dir: StrPath = ...,
        name: str = ...,
        depth: int = 0,
        files_matching: str = ...,
        ignore_files: NotSupported = ...,
        extensions: NotSupported = ...,
        ignore_unknown_extensions: bool = False,
    ) -> RunnerResults: ...
    @overload
    def include_vars(self, arg: str, /) -> RunnerResults: ...
    def lineinfile(
        self,
        *,
        path: StrPath,
        regexp: str = ...,
        state: Literal['absent', 'present'] = 'present',
        line: str = ...,
        backrefs: bool = False,
        insertafter: str = 'EOF',
        insertbefore: str = ...,
        create: bool = False,
        backup: bool = False,
        firstmatch: bool = False,
        others: str = ...,
    ) -> RunnerResults: ...
    def package_facts(
        self,
        *,
        manager: NotSupported = ...,
        strategy: Literal['first', 'all'] = 'first',
    ) -> RunnerResults: ...
    def pause(
        self,
        *,
        minutes: str = ...,
        seconds: str = ...,
        prompt: str = ...,
        echo: bool = True,
    ) -> RunnerResults: ...
    def ping(
        self,
        *,
        data: str = 'pong',
    ) -> RunnerResults: ...
    def pip(
        self,
        *,
        name: NotSupported = ...,
        version: str = ...,
        requirements: str = ...,
        virtualenv: StrPath = ...,
        virtualenv_site_packages: bool = False,
        virtualenv_command: StrPath = 'virtualenv',
        virtualenv_python: str = ...,
        state: Literal['absent', 'forcereinstall', 'latest', 'present'] = 'present',
        extra_args: str = ...,
        editable: bool = False,
        chdir: StrPath = ...,
        executable: StrPath = ...,
        umask: str = ...,
    ) -> RunnerResults: ...
    def reboot(
        self,
        *,
        pre_reboot_delay: int = 0,
        post_reboot_delay: int = 0,
        reboot_timeout: int = 600,
        connect_timeout: int = ...,
        test_command: str = 'whoami',
        msg: str = ...,
        search_paths: NotSupported = ...,
        boot_time_command: str = ...,
    ) -> RunnerResults: ...
    def replace(
        self,
        *,
        path: StrPath,
        regexp: str,
        replace: str = ...,
        after: str = ...,
        before: str = ...,
        backup: bool = False,
        others: str = ...,
        encoding: str = 'utf-8',
    ) -> RunnerResults: ...
    def rpm_key(
        self,
        *,
        key: str,
        state: Literal['absent', 'present'] = 'present',
        validate_certs: bool = True,
        fingerprint: str = ...,
    ) -> RunnerResults: ...
    def service(
        self,
        *,
        name: str,
        state: Literal['reloaded', 'restarted', 'started', 'stopped'] = ...,
        sleep: int = ...,
        pattern: str = ...,
        enabled: bool = ...,
        runlevel: str = 'default',
        arguments: str = ...,
        use: str = 'auto',
    ) -> RunnerResults: ...
    def service_facts(self) -> RunnerResults: ...
    @overload
    def shell(
        self,
        *,
        cmd: str = ...,
        creates: StrPath = ...,
        removes: StrPath = ...,
        chdir: StrPath = ...,
        executable: StrPath = ...,
        warn: bool = True,
        stdin: str = ...,
        stdin_add_newline: bool = True,
    ) -> RunnerResults: ...
    @overload
    def shell(self, arg: str, /) -> RunnerResults: ...
    def slurp(
        self,
        *,
        src: StrPath,
    ) -> RunnerResults: ...
    def stat(
        self,
        *,
        path: StrPath,
        follow: bool = False,
        get_checksum: bool = True,
        checksum_algorithm: Literal['md5', 'sha1', 'sha224', 'sha256', 'sha384', 'sha512'] = 'sha1',
        get_mime: bool = True,
        get_attributes: bool = True,
    ) -> RunnerResults: ...
    def subversion(
        self,
        *,
        repo: str,
        dest: str,
        revision: str = 'HEAD',
        force: bool = False,
        in_place: bool = False,
        username: str = ...,
        password: str = ...,
        executable: str = ...,
        checkout: bool = True,
        update: bool = True,
        export: bool = False,
        switch: bool = True,
    ) -> RunnerResults: ...
    def systemd(
        self,
        *,
        name: str = ...,
        state: Literal['reloaded', 'restarted', 'started', 'stopped'] = ...,
        enabled: bool = ...,
        force: bool = ...,
        masked: bool = ...,
        daemon_reload: bool = False,
        daemon_reexec: bool = False,
        user: bool = ...,
        scope: Literal['system', 'user', 'global'] = 'system',
        no_block: bool = False,
    ) -> RunnerResults: ...
    def systemd_service(
        self,
        *,
        name: str = ...,
        state: Literal['reloaded', 'restarted', 'started', 'stopped'] = ...,
        enabled: bool = ...,
        force: bool = ...,
        masked: bool = ...,
        daemon_reload: bool = False,
        daemon_reexec: bool = False,
        scope: Literal['system', 'user', 'global'] = 'system',
        no_block: bool = False,
    ) -> RunnerResults: ...
    def sysvinit(
        self,
        *,
        name: str,
        state: Literal['started', 'stopped', 'restarted', 'reloaded'] = ...,
        enabled: bool = ...,
        sleep: int | str = 1,
        pattern: str = ...,
        runlevels: str = ...,
        arguments: str = ...,
        daemonize: bool = False,
    ) -> RunnerResults: ...
    def tempfile(
        self,
        *,
        state: Literal['directory', 'file'] = 'file',
        path: StrPath = ...,
        prefix: str = 'ansible.',
        suffix: str = '',
    ) -> RunnerResults: ...
    def uri(
        self,
        *,
        url: str,
        dest: StrPath = ...,
        url_username: str = ...,
        url_password: str = ...,
        body: str = ...,
        body_format: Literal['form-urlencoded', 'json', 'raw', 'form-multipart'] = 'raw',
        method: str = 'GET',
        return_content: bool = False,
        force_basic_auth: bool = False,
        follow_redirects: Literal['all', 'no', 'none', 'safe', 'urllib2', 'yes'] = 'safe',
        creates: StrPath = ...,
        removes: StrPath = ...,
        status_code: NotSupported = ...,
        timeout: int = 30,
        headers: NotSupported = ...,
        validate_certs: bool = True,
        client_cert: StrPath = ...,
        client_key: StrPath = ...,
        src: StrPath = ...,
        remote_src: bool = False,
        force: bool = False,
        use_proxy: bool = True,
        unix_socket: str = ...,
        http_agent: str = 'ansible-httpget',
    ) -> RunnerResults: ...
    def user(
        self,
        *,
        name: str,
        uid: int = ...,
        comment: str = ...,
        hidden: bool = ...,
        non_unique: bool = False,
        seuser: str = ...,
        group: str = ...,
        groups: NotSupported = ...,
        append: bool = False,
        shell: str = ...,
        home: StrPath = ...,
        skeleton: str = ...,
        password: str = ...,
        state: Literal['absent', 'present'] = 'present',
        create_home: bool = True,
        move_home: bool = False,
        system: bool = False,
        force: bool = False,
        remove: bool = False,
        login_class: str = ...,
        generate_ssh_key: bool = False,
        ssh_key_bits: int = ...,
        ssh_key_type: str = 'rsa',
        ssh_key_file: StrPath = ...,
        ssh_key_comment: str = ...,
        ssh_key_passphrase: str = ...,
        update_password: Literal['always', 'on_create'] = 'always',
        expires: Incomplete = ...,
        password_lock: bool = ...,
        local: bool = False,
        profile: str = ...,
        authorization: str = ...,
        role: str = ...,
    ) -> RunnerResults: ...
    def validate_argument_spec(
        self,
        *,
        argument_spec: str,
        provided_arguments: str = ...,
    ) -> RunnerResults: ...
    def wait_for(
        self,
        *,
        host: str = '127.0.0.1',
        timeout: int = 300,
        connect_timeout: int = 5,
        delay: int = 0,
        port: int = ...,
        active_connection_states: NotSupported = ...,
        state: Literal['absent', 'drained', 'present', 'started', 'stopped'] = 'started',
        path: StrPath = ...,
        search_regex: str = ...,
        exclude_hosts: NotSupported = ...,
        sleep: int = 1,
        msg: str = ...,
    ) -> RunnerResults: ...
    def wait_for_connection(
        self,
        *,
        connect_timeout: int = 5,
        delay: int = 0,
        sleep: int = 1,
        timeout: int = 600,
    ) -> RunnerResults: ...
    def yum_repository(
        self,
        *,
        async_: bool = True,
        bandwidth: int | str = 0,
        baseurl: str = ...,
        cost: int | str = 1000,
        deltarpm_metadata_percentage: int | str = 100,
        deltarpm_percentage: int | str = 75,
        description: str = ...,
        enabled: bool = True,
        enablegroups: bool = True,
        exclude: str = ...,
        failovermethod: Literal['roundrobin', 'priority'] = 'roundrobin',
        file: str = ...,
        gpgcakey: str = ...,
        gpgcheck: bool = ...,
        gpgkey: str = ...,
        http_caching: Literal['all', 'packages', 'none'] = 'all',
        include: str = ...,
        includepkgs: str = ...,
        ip_resolve: Literal[4, 6, 'IPv4', 'IPv6', 'whatever'] = 'whatever',
        keepalive: bool = False,
        keepcache: Literal['0', '1'] = '1',
        metadata_expire: int | str = 21600,
        metadata_expire_filter: Literal['never', 'read-only:past', 'read-only:present', 'read-only:future'] = 'read-only:present',
        metalink: str = ...,
        mirrorlist: str = ...,
        mirrorlist_expire: int | str = 21600,
        name: str,
        password: str = ...,
        priority: int | str = 99,
        protect: bool = False,
        proxy: str = ...,
        proxy_password: str = ...,
        proxy_username: str = ...,
        repo_gpgcheck: bool = False,
        reposdir: str = '/etc/yum.repos.d',
        retries: int | str = 10,
        s3_enabled: bool = False,
        skip_if_unavailable: bool = False,
        ssl_check_cert_permissions: bool = False,
        sslcacert: str = ...,
        sslclientcert: str = ...,
        sslclientkey: str = ...,
        sslverify: bool = True,
        state: Literal['absent', 'present'] = 'present',
        throttle: str = ...,
        timeout: int | str = 30,
        ui_repoid_vars: str = ...,
        username: str = ...,
    ) -> RunnerResults: ...
